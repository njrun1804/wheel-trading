"""
Automated Decision Engine with Safety Limits

Coordinates the trading advisor, risk management, and execution with
comprehensive safety controls and monitoring.
"""

import asyncio
from datetime import datetime, UTC
from typing import Dict, Any, Optional, List
import logging

# Use TYPE_CHECKING to avoid circular import
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..api.advisor import WheelAdvisor
from ..risk.limits import RiskLimitChecker, RiskLimit
from ..utils.logging import get_logger

logger = get_logger(__name__)


class DecisionEngine:
    """
    Automated decision engine with comprehensive safety controls.
    
    Coordinates all trading decisions through the advisor while enforcing
    risk limits and safety mechanisms.
    """
    
    def __init__(self, advisor: "WheelAdvisor", risk_checker: RiskLimitChecker):
        """Initialize decision engine with advisor and risk checker."""
        self.advisor = advisor
        self.risk_checker = risk_checker
        self.decision_history: List[Dict[str, Any]] = []
        self.emergency_stop = False
        
        logger.info("Decision engine initialized with safety controls")
    
    async def generate_decision(self, market_snapshot: Dict[str, Any], dry_run: bool = False) -> Optional[Dict[str, Any]]:
        """
        Generate trading decision with full safety validation.
        
        Args:
            market_snapshot: Current market data
            dry_run: If True, don't execute, just validate
            
        Returns:
            Decision dictionary or None if blocked by safety
        """
        if self.emergency_stop:
            logger.warning("Decision blocked - emergency stop active")
            return None
        
        start_time = datetime.now(UTC)
        decision_id = f"decision_{int(start_time.timestamp())}"
        
        try:
            # Generate recommendation from advisor
            recommendation = self.advisor.advise_position(market_snapshot)
            
            if not recommendation:
                logger.warning("No recommendation generated by advisor")
                return None
            
            # Convert recommendation to decision format
            decision = {
                "id": decision_id,
                "timestamp": start_time,
                "action": recommendation.action,
                "rationale": recommendation.rationale,
                "confidence": recommendation.confidence,
                "details": recommendation.details,
                "risk_metrics": recommendation.risk,
                "dry_run": dry_run,
                "safety_approved": False  # Will be set by risk checker
            }
            
            # Check risk limits
            portfolio_value = market_snapshot.get("buying_power", 100000)
            risk_breaches = self.risk_checker.check_all_limits(
                recommendation=decision,
                portfolio_value=portfolio_value,
                market_data=market_snapshot
            )
            
            # Determine if trade should be allowed
            should_allow = self.risk_checker.should_allow_trade(risk_breaches)
            decision["safety_approved"] = should_allow
            decision["risk_breaches"] = [
                {
                    "name": breach.name,
                    "current": breach.current_value,
                    "limit": breach.limit_value,
                    "severity": breach.severity,
                    "action": breach.action
                }
                for breach in risk_breaches
            ]
            
            if not should_allow:
                logger.warning(f"Decision {decision_id} blocked by risk limits")
                logger.warning(f"Breaches: {[b.name for b in risk_breaches]}")
                decision["action"] = "HOLD"
                decision["rationale"] = f"Blocked by risk limits: {', '.join(b.name for b in risk_breaches)}"
            
            # Record decision
            self.decision_history.append(decision)
            
            # Log decision
            logger.info(f"Decision generated: {decision['action']}")
            logger.info(f"  Confidence: {decision['confidence']:.1%}")
            logger.info(f"  Safety approved: {decision['safety_approved']}")
            if risk_breaches:
                logger.info(f"  Risk breaches: {len(risk_breaches)}")
            
            return decision
            
        except Exception as e:
            logger.error(f"Error generating decision: {e}", exc_info=True)
            return None
    
    def activate_emergency_stop(self, reason: str = "Manual override") -> None:
        """Activate emergency stop to block all decisions."""
        self.emergency_stop = True
        logger.error(f"ðŸš¨ EMERGENCY STOP ACTIVATED: {reason}")
    
    def deactivate_emergency_stop(self) -> None:
        """Deactivate emergency stop."""
        self.emergency_stop = False
        logger.info("Emergency stop deactivated")
    
    def get_decision_statistics(self) -> Dict[str, Any]:
        """Get statistics about recent decisions."""
        if not self.decision_history:
            return {"total_decisions": 0}
        
        recent_decisions = self.decision_history[-100:]  # Last 100 decisions
        
        stats = {
            "total_decisions": len(self.decision_history),
            "recent_decisions": len(recent_decisions),
            "actions": {},
            "average_confidence": 0.0,
            "safety_approval_rate": 0.0,
            "common_risk_breaches": {}
        }
        
        # Count actions
        for decision in recent_decisions:
            action = decision.get("action", "UNKNOWN")
            stats["actions"][action] = stats["actions"].get(action, 0) + 1
        
        # Calculate averages
        if recent_decisions:
            total_confidence = sum(d.get("confidence", 0) for d in recent_decisions)
            stats["average_confidence"] = total_confidence / len(recent_decisions)
            
            approved_count = sum(1 for d in recent_decisions if d.get("safety_approved", False))
            stats["safety_approval_rate"] = approved_count / len(recent_decisions)
            
            # Count risk breaches
            for decision in recent_decisions:
                for breach in decision.get("risk_breaches", []):
                    breach_name = breach.get("name", "unknown")
                    stats["common_risk_breaches"][breach_name] = stats["common_risk_breaches"].get(breach_name, 0) + 1
        
        return stats