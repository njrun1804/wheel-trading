#!/usr/bin/env python3
"""
Safe Cleanup Alternative - Agent 7 (P-Core 6)
Identifies only truly disposable files for safe cleanup
"""

import subprocess
from pathlib import Path


class SafeCleanupAnalyzer:
    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path).absolute()

    def get_all_deleted_files(self) -> list[str]:
        """Get all files marked for deletion"""
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
            )

            deleted_files = []
            for line in result.stdout.strip().split("\n"):
                if line.startswith("D "):
                    filename = line[3:].strip()
                    if filename.startswith('"') and filename.endswith('"'):
                        filename = filename[1:-1]
                    deleted_files.append(filename)

            return deleted_files
        except subprocess.CalledProcessError:
            return []

    def categorize_files(self, deleted_files: list[str]) -> dict[str, list[str]]:
        """Categorize files into safe vs dangerous to delete"""

        # Files that are SAFE to delete (generated, cache, artifacts)
        safe_patterns = [
            # Coverage files
            r"\.coverage",
            r"coverage\.xml",
            # Test databases and indexes
            r"\.test_index/",
            r"/\.test_index/",
            # Python cache
            r"__pycache__/",
            r"\.pyc$",
            r"\.pyo$",
            # Build artifacts
            r"\.egg-info/",
            r"/build/",
            r"/dist/",
            # IDE files
            r"\.vscode/",
            r"\.idea/",
            # Temporary files
            r"\.tmp$",
            r"\.temp$",
            r"~$",
            # Log files
            r"\.log$",
            r"\.log\.",
            # Database files that can be regenerated
            r"\.jarvis/experience\.db",
            r"\.jarvis/experience/experiences\.db",
            # Backup files
            r"\.backup$",
            r"\.bak$",
            # OS files
            r"\.DS_Store$",
            r"Thumbs\.db$",
        ]

        # Files that are DANGEROUS to delete (core functionality)
        dangerous_patterns = [
            # Source code
            r"src/",
            r"\.py$",
            # Configuration
            r"config\.yaml$",
            r"pyproject\.toml$",
            r"requirements.*\.txt$",
            r"setup\.py$",
            r"\.gitignore$",
            r"\.env",
            # Documentation
            r"README\.md$",
            r"CLAUDE\.md$",
            r"\.md$",
            # Package structure
            r"__init__\.py$",
            r"__main__\.py$",
            # Git and CI
            r"\.github/",
            r"\.git/",
            # Essential scripts
            r"run\.py$",
            r"main\.py$",
            # Makefile and build
            r"Makefile$",
            r"\.mk$",
        ]

        import re

        safe_to_delete = []
        dangerous_to_delete = []
        unclear = []

        for file_path in deleted_files:
            is_safe = any(re.search(pattern, file_path) for pattern in safe_patterns)
            is_dangerous = any(
                re.search(pattern, file_path) for pattern in dangerous_patterns
            )

            if is_dangerous:
                dangerous_to_delete.append(file_path)
            elif is_safe:
                safe_to_delete.append(file_path)
            else:
                unclear.append(file_path)

        return {
            "safe_to_delete": safe_to_delete,
            "dangerous_to_delete": dangerous_to_delete,
            "unclear": unclear,
        }

    def generate_safe_cleanup_commands(self, safe_files: list[str]) -> str:
        """Generate git commands to safely remove only disposable files"""

        if not safe_files:
            return "# No safe files identified for deletion"

        commands = [
            "#!/bin/bash",
            "# Safe Cleanup Commands - Generated by Agent 7",
            "# Only removes cache, build artifacts, and regenerable files",
            "",
            "set -e  # Exit on any error",
            "",
            "echo 'Starting safe cleanup of disposable files...'",
            "",
        ]

        for file_path in safe_files:
            # Escape file paths with spaces
            file_path.replace(" ", "\\ ")
            commands.append(f"git rm --cached '{file_path}' 2>/dev/null || true")

        commands.extend(
            [
                "",
                "echo 'Safe cleanup completed!'",
                "echo 'Cleaned files:'",
            ]
        )

        for file_path in safe_files:
            commands.append(f"echo '  - {file_path}'")

        return "\n".join(commands)

    def analyze_and_report(self) -> dict:
        """Full analysis and safety report"""
        deleted_files = self.get_all_deleted_files()
        categorized = self.categorize_files(deleted_files)

        report = {
            "total_files": len(deleted_files),
            "safe_count": len(categorized["safe_to_delete"]),
            "dangerous_count": len(categorized["dangerous_to_delete"]),
            "unclear_count": len(categorized["unclear"]),
            "categorized_files": categorized,
            "safety_percentage": (
                len(categorized["safe_to_delete"]) / len(deleted_files) * 100
            )
            if deleted_files
            else 0,
        }

        return report


def main():
    repo_path = "/Users/mikeedwards/Library/Mobile Documents/com~apple~CloudDocs/pMike/Wheel/wheel-trading"
    analyzer = SafeCleanupAnalyzer(repo_path)

    print("🔍 Analyzing files for safe cleanup...")
    report = analyzer.analyze_and_report()

    print("\n" + "=" * 60)
    print("SAFE CLEANUP ANALYSIS REPORT")
    print("=" * 60)
    print(f"Total files marked for deletion: {report['total_files']}")
    print(
        f"Safe to delete: {report['safe_count']} ({report['safety_percentage']:.1f}%)"
    )
    print(f"Dangerous to delete: {report['dangerous_count']}")
    print(f"Unclear/Need review: {report['unclear_count']}")

    if report["safe_count"] > 0:
        print("\n✅ Safe files to delete:")
        for file_path in report["categorized_files"]["safe_to_delete"][
            :10
        ]:  # Show first 10
            print(f"   - {file_path}")
        if len(report["categorized_files"]["safe_to_delete"]) > 10:
            print(
                f"   ... and {len(report['categorized_files']['safe_to_delete']) - 10} more"
            )

    if report["dangerous_count"] > 0:
        print("\n⚠️  Dangerous files (DO NOT DELETE):")
        for file_path in report["categorized_files"]["dangerous_to_delete"][
            :10
        ]:  # Show first 10
            print(f"   - {file_path}")
        if len(report["categorized_files"]["dangerous_to_delete"]) > 10:
            print(
                f"   ... and {len(report['categorized_files']['dangerous_to_delete']) - 10} more"
            )

    # Generate safe cleanup script
    if report["safe_count"] > 0:
        cleanup_script = analyzer.generate_safe_cleanup_commands(
            report["categorized_files"]["safe_to_delete"]
        )

        script_path = Path(repo_path) / "safe_cleanup_script.sh"
        with open(script_path, "w") as f:
            f.write(cleanup_script)

        print(f"\n📄 Safe cleanup script generated: {script_path}")
        print("To execute safe cleanup:")
        print(f"   chmod +x {script_path}")
        print(f"   ./{script_path.name}")

    return report


if __name__ == "__main__":
    main()
